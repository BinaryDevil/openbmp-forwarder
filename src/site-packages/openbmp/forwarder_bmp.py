# -*- coding: utf-8 -*-
"""OpenBMP forwarder

  Copyright (c) 2013-2015 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import socket
import multiprocessing

from time import sleep
from openbmp.logger import init_mp_logger


class BMPWriter(multiprocessing.Process):
    """ BMP Forwarder

        Pops messages from forwarder queue and transmits them to remote bmp collector.
    """

    SOCKET_TIMEOUT = 5

    def __init__(self, cfg, forward_queue, log_queue):
        """ Constructor

            :param cfg:             Configuration dictionary
            :param forward_queue:   Output for BMP raw message forwarding
            :param log_queue:       Logging queue - sync logging
        """
        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._fwd_queue = forward_queue
        self._log_queue = log_queue
        self.LOG = None
        self._dest_socks = {}

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("bmp_writer", self._log_queue)

        self.LOG.info("Running bmp_writer")

        self.connect()

        try:
            # wait for the mapping config to be loaded
            while not self.stopped():
                if self._cfg and 'logging' in self._cfg:
                    break

            # Read queue
            while not self.stopped():

                # Do not pop any message unless connected
                msg = self._fwd_queue.get()

                if msg == 'DISCONNECT ALL':
                    self.disconnect()

                else:
                    if msg.DEST_CONFIG_NAME not in self._dest_socks:
                        self.connect(msg.DEST_CONFIG_NAME)

                    sock_arr = self._dest_socks[msg.DEST_CONFIG_NAME]
                    if sock_arr[1]:
                        sent = False
                        while not sent:
                            sent = self.send(msg.BMP_MSG, sock_arr[0])

                        self.LOG.debug("Received bmp message: %s %s %s", msg.COLLECTOR_ADMIN_ID,
                                       msg.ROUTER_IP, msg.ROUTER_NAME)
                    else:
                        self.LOG.info("Peer group \'{}\' not connected, attempting to reconnect".format(msg.DEST_CONFIG_NAME))
                        sock_arr[1] = self.connect(msg.DEST_CONFIG_NAME)

        except KeyboardInterrupt:
            pass

        self.LOG.info("rewrite stopped")

    def connect(self, peer_group_name=None):
        """ Connect to remote controller

        :param peer_group_name: the name of peer_group config
        :return: if no peer_group_name given, return connection status
        """
        for peer_group in self._cfg['dest_peer_groups']:
            if peer_group_name is None or peer_group_name == peer_group['name']:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                is_connected = None
                sock.settimeout(self.SOCKET_TIMEOUT)
                try:
                    sock.connect((peer_group['collector']['host'], peer_group['collector']['port']))
                    is_connected = True
                    self.LOG.info("Connected to remote collector: %s:%d", peer_group['collector']['host'],
                                  peer_group['collector']['port'])
                except socket.error as msg:
                    self.LOG.error("Failed to connect to remote collector: %r", msg)
                    is_connected = False
                finally:
                    self._dest_socks[peer_group['name']] = [sock, is_connected]
                    if peer_group_name is not None:
                        return is_connected

    def send(self, msg, sock):
        """ Send BMP message to socket.

            :param msg:     Message to send/write

            :return: True if sent, False if not sent
        """
        sent = False

        try:
            sock.sendall(msg)
            sent = True

        except socket.error as msg:
            self.LOG.error("Failed to send message to collector: %r", msg)

        return sent

    def disconnect(self):
        """ Disconnect from remote collector
        """
        for key, sock_arr in self._dest_socks:
            sock_arr[0].close()
            del self._dest_socks[key]

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()
